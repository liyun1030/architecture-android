TH_EXPORT_CPP_API_add：
宏作用：将 C++ 函数 add 导出为 C 兼容的 API，解决 C++ 名称修饰（Name Mangling）问题。
典型实现：该宏可能展开为类似以下代码：
// 假设宏展开为
TH_EXPORT_CPP_API_add(add);
extern "C" {
    const char* add(int32_t a, int32_t b);
}

using namespace taihe;
作用：引入 taihe 命名空间的所有内容，使其中的标识符（如类、函数、变量）无需加前缀即可使用

extern 关键字：
用于声明变量或函数的全局可见性，告知编译器这些符号（Symbol）的定义存在于其他文件或模块中。以下是其核心用法及场景：
若声明时赋值（如 extern int x = 10;），则变为定义，违反 “单一定义规则”
// file1.cpp
int globalVar = 42;  // 定义全局变量

// file2.cpp
extern int globalVar;  // 声明外部变量（不分配内存）

void func() {
    globalVar = 100;  // 使用 file1.cpp 中定义的变量
}

// math.h
extern int add(int a, int b);  // 声明（extern 可省略）

// math.cpp
int add(int a, int b) {  // 定义
    return a + b;
}

#ifdef _WIN32
#define EXPORT __declspec(dllexport)
#else
#define EXPORT
#endif
为什么要重复写这些ifdef,define之类，直接define不行吗，看着别扭
这段代码中的 #ifdef _WIN32 条件编译是为了兼容不同操作系统的动态链接库（DLL）导出机制。直接使用 #define 会导致代码在非 Windows 平台上出错
// 库头文件
#ifdef LIBRARY_BUILD
// 编译库时，导出符号
#define API EXPORT
#else
// 使用库时，导入符号
#define API __declspec(dllimport)  // Windows 专用
#endif

// 声明导出的函数
API void library_function();


hpp文件和.h文件的区别
.h：通用头文件扩展名，适用于 C/C++ 混合项目，强调兼容性。
.hpp：C++ 专用头文件扩展名，适用于纯 C++ 项目，强调现代 C++ 特性。

互斥所：
std::lock_guard<ffrt::mutex> lock(mutex_);
使用 OpenHarmony 的轻量级互斥锁ffrt::mutex保证线程安全
通过 RAII 方式（std::lock_guard）自动管理锁的生命周期
防止多线程同时修改观察者列表导致的数据竞争问题
int g_num=0;
void slow_increat(int id){
 for(int i=0;i<3;++i){
   g_num_mutex.lock()
   ++g_num;
   g_num_mutex.unlock()
   std::this_thread::sleep_for(std::chrono:seconds(1))
 }
 }
 int main(){
 std:thread t1(slow_increat,0)
 std:thread t2(slow_increat,1)

}

死锁（Deadlock）
产生条件：
互斥条件
占有并等待
不可抢占
循环等待
优先使用 RAII 风格锁：std::lock_guard 和 std::unique_lock
避免手动加锁 / 解锁：减少死锁风险
控制锁的粒度：过粗影响性能，过细增加复杂度
统一加锁顺序：防止循环等待
考虑读写锁：适用于多读少写场景
性能敏感场景：使用 OpenHarmony 的 ffrt::mutex
在 C++ 中，std::lock_guard 对象的构造和析构时机与它的生命周期管理密切相关。根据 RAII（资源获取即初始化）原则，构造时获取锁，析构时释放锁。具体来说：
一、构造时机
当std::lock_guard对象被创建时，立即构造并加锁：

cpp
运行
{
    std::lock_guard<std::mutex> lock(mtx);  // 构造对象，立即调用mtx.lock()
    // 临界区代码
}  // 作用域结束，lock自动析构，调用mtx.unlock()
1. 显式构造
直接声明变量：
cpp
运行
void func() {
    std::lock_guard<std::mutex> lock(mtx);  // 进入作用域时构造
    // ...
}  // 离开作用域时析构

作为函数参数传递：
cpp
运行
void wrapper(std::lock_guard<std::mutex> lock) {
    // lock已在传入前构造完成
}

// 调用时构造
wrapper(std::lock_guard<std::mutex>(mtx));

2. 隐式构造（通过花括号限定作用域）
cpp
运行
void func() {
    // 未加锁代码
    
    {  // 开始新的块作用域
        std::lock_guard<std::mutex> lock(mtx);  // 构造并加锁
        // 临界区
    }  // 作用域结束，自动解锁
    
    // 未加锁代码
}
二、析构时机
当std::lock_guard对象的生命周期结束时，自动析构并解锁：
1. 作用域结束
cpp
运行
void func() {
    if (condition) {
        std::lock_guard<std::mutex> lock(mtx);  // 构造
        // 临界区
    }  // if语句块结束，lock析构
}  // 函数结束时，lock已提前析构
2. 提前返回
cpp
运行
void func() {
    std::lock_guard<std::mutex> lock(mtx);  // 构造
    
    if (error_condition) {
        return;  // 提前返回，lock在此处析构
    }
    
    // ...
}  // 正常结束时，lock也会析构
3. 异常抛出
cpp
运行
void func() {
    std::lock_guard<std::mutex> lock(mtx);  // 构造
    
    throw std::runtime_error("Exception");  // 异常抛出，lock析构（栈展开）
}  // 异常未被捕获，函数终止，lock已析构
三、对比手动锁与 RAII 的优势
对比你的代码：

cpp
运行
void unsafe_increment() {
    for (int i = 0; i < 100000; ++i) {
        mtx.lock();  // 手动加锁
        ++shared_data;
        mtx.unlock();  // 手动解锁（必须确保执行，否则死锁）
    }
}

问题场景：

若++shared_data抛出异常，mtx.unlock()不会执行，导致死锁
若中间有return语句，也会跳过解锁

使用std::lock_guard改进：

cpp
运行
void safe_increment() {
    for (int i = 0; i < 100000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);  // 自动加锁
        ++shared_data;  // 无论是否抛异常或提前返回，lock都会析构
    }  // 每次循环结束，lock析构，解锁
}
四、关键总结
操作	时机
std::lock_guard构造	对象被创建时（如变量声明、函数参数传递、临时对象创建）
std::lock_guard析构	对象生命周期结束时（如作用域结束、提前返回、异常抛出导致栈展开）
锁获取	构造函数调用mutex::lock()
锁释放	析构函数调用mutex::unlock()
五、最佳实践
用花括号限定锁的作用域：
cpp
运行
void func() {
    // 无需锁的代码
    {
        std::lock_guard<std::mutex> lock(mtx);
        // 仅在必要区域加锁
    }
    
    // 无需锁的代码
}

避免复制std::lock_guard：
它不可复制（拷贝构造函数被删除）
只能移动（std::unique_lock支持）
嵌套锁的作用域：
cpp
运行
void nested() {
    {
        std::lock_guard<std::mutex> lock1(mtx1);
        
        {
            std::lock_guard<std::mutex> lock2(mtx2);
            // 同时持有lock1和lock2
        }  // lock2先析构
        
        // 只持有lock1
    }  // lock1析构
}
通过 RAII 机制，std::lock_guard确保锁的获取和释放总是成对出现，避免手动管理锁时的常见错误


std::vector<std::shared_ptr<EnableAbilityListsObserver>> installAbilityListsObservers_ = {};

void EnableAbilityListsObserverImpl::OnInstallAbilityListsStateChanged()
{
    HILOG_DEBUG();
    std::lock_guard<ffrt::mutex> lock(mutex_);
    for (auto &observer : installAbilityListsObservers_) {
        if (observer) {
            observer->OnEnableAbilityListsStateChanged();
        } else {
            HILOG_ERROR("observer is null");
        }
    }
}
在 C++ 中，auto &observer 是一种类型推导和引用结合的语法，用于简化迭代器的使用。让我详细解释它的含义和作用：
int x = 42;
auto y = x;  // y 被推导为 int 类型


C++的智能指针unique_ptr、shared_ptr和weak_ptr
C++的智能指针是一种特殊的指针类型，它能够自动管理内存资源，避免常见的内存泄漏和多次释放等问题。C++11引入了三种主要的智能指针：unique_ptr、shared_ptr和weak_ptr。

①unique_ptr
在C++中，unique_ptr是一个智能指针（smart pointer）类模板，用于管理动态分配的内存资源，它提供了自动释放内存的功能。与原始指针相比，unique_ptr有更高的安全性和易用性。

unique_ptr具有以下特点：

独占所有权：每个unique_ptr实例拥有对其所指向对象的唯一所有权。这意味着在任何时候只有一个unique_ptr可以指向一个特定的对象。

自动释放内存：当unique_ptr超出作用域或被重新赋值时，它所管理的内存会自动释放。这样就避免了内存泄漏的问题。

指针语义：unique_ptr的使用方式与原始指针相似，可以通过指针操作符（->）和解引用操作符（*）来访问所指向对象的成员。

不可拷贝：unique_ptr是不可拷贝的，即不能进行复制构造和赋值操作。这是为了确保独占所有权的特性，防止多个指针同时管理同一个对象的内存。

支持移动语义：unique_ptr支持移动构造和移动赋值操作，可以将所有权转移给新的unique_ptr，而无需进行内存拷贝。

可自定义删除器：unique_ptr可以通过模板参数来指定一个删除器（deleter）函数对象，用于在释放内存时执行额外的清理操作。
②shared_ptr
在C++中，shared_ptr是一个智能指针（smart pointer）类模板，用于管理动态分配的内存资源。与unique_ptr相比，shared_ptr可以实现多个指针共享同一块内存，并且提供了自动释放内存的功能。

shared_ptr具有以下特点：

共享所有权：多个shared_ptr实例可以同时指向同一个对象，它们共享对所指向对象的所有权。只有当所有shared_ptr都超出作用域或被重新赋值时，才会释放所管理的内存。

自动释放内存：当最后一个指向对象的shared_ptr超出作用域或被重新赋值时，它会自动释放所管理的内存。这种机制称为引用计数（reference counting），通过计数器来追踪当前有多少个shared_ptr指向同一块内存。

指针语义：shared_ptr的使用方式与原始指针相似，可以通过指针操作符（->）和解引用操作符（*）来访问所指向对象的成员。

可拷贝：shared_ptr是可拷贝的，即可以进行复制构造和赋值操作。每次拷贝会增加引用计数。当引用计数变为0时，表示没有任何shared_ptr指向该内存，会释放内存。

③weak_ptr
在 C++ 中，weak_ptr 是一种智能指针（smart pointer），用于解决循环引用问题。它是由 shared_ptr 派生而来，但不会增加引用计数，只是对所指向对象进行观察，并不拥有对象的所有权。

循环引用问题

循环引用问题指的是在使用shared_ptr管理对象时，存在两个或多个对象相互持有shared_ptr，形成一个循环引用的情况。这种情况下，每个对象的引用计数都不会变为0，导致内存泄漏。

具体来说，当两个对象相互持有shared_ptr时，它们的引用计数始终大于0，因此它们所指向的内存块永远不会被释放。即使程序使用结束，这部分内存也无法回收，造成了内存泄漏的问题。

循环引用问题的实际场景可能是两个对象之间存在双向关联，比如A对象持有shared_ptr指向B对象，而B对象也持有shared_ptr指向A对象。当这两个对象的生命周期延长，超过了程序实际需要它们的时间时，就会造成循环引用和内存泄露。

为了解决循环引用问题，C++中引入了弱引用指针weak_ptr。弱引用指针和shared_ptr不同，它不会增加引用计数，只是对所指向对象进行观察，并不拥有对象的所有权。通过弱引用指针，我们可以在需要时使用lock()函数获取一个有效的shared_ptr来操作对象，一旦对象的引用计数变为0，弱引用指针将自动失效。

使用弱引用指针可以破坏循环引用，让所有的shared_ptr都能够正常析构并释放所管理的内存，避免了潜在的内存泄漏风险。

weak_ptr 具有以下特点和用法：

弱引用：因为 weak_ptr 不会增加引用计数，所以当所有 shared_ptr 都释放后，weak_ptr 将自动失效。它允许你观察一个对象，但不影响其生命周期。

通过 shared_ptr 创建：通常，我们使用 shared_ptr 来初始化 weak_ptr。这样可以确保 weak_ptr 观察的对象仍然存在。

使用 lock() 获取 shared_ptr：要操作 weak_ptr 所观察的对象，可以使用 lock() 函数获取一个有效的 shared_ptr。如果原始的 shared_ptr 已经被释放，lock() 返回一个空的 shared_ptr。

判断是否有效：可以使用 expired() 函数来检查 weak_ptr 是否已经失效，即所观察的 shared_ptr 是否已经被释放。

解决循环引用问题：由于 weak_ptr 不增加引用计数，可以用于解决两个或多个对象之间的循环引用问题，避免内存泄漏。
自定义删除器
struct Deleter {
    void operator()(int* p) {
        std::cout << "Custom deleter called" << std::endl;
        delete p;
    }
};

std::unique_ptr<int, Deleter> ptr3(new int(100), Deleter());
函数对象（Functor）：通过重载 operator() 使结构体可调用
参数：接受一个 int* 类型的指针（即 unique_ptr 管理的资源）
功能：在删除资源前打印日志，然后使用 delete 释放内存


public:
  IUserImpl(string_view path) : m_email(path) {}

  string getEmail() {
    return this->m_email;
  }

  void setEmail(string_view path) {
    this->m_email = path;
  }

private:
  string m_email;
};
m_email是初始化列表的方法
初始化列表的作用
在 C++ 构造函数中，初始化列表（Initializer List）用于在对象构造时对成员变量进行初始化。语法格式为
ClassName(参数列表) : 成员变量1(初值1), 成员变量2(初值2) {
    // 构造函数体
}

#include "user.impl.hpp"
#include "stdexcept"
#include "taihe/runtime.hpp"
#include "user.proj.hpp"

using namespace taihe;
using namespace user;

namespace {
class IUserImpl {
public:
  IUserImpl(string_view path) : m_email(path) {}

  string getEmail() {
    return this->m_email;
  }

  void setEmail(string_view path) {
    this->m_email = path;
  }

private:
  string m_email;
};

IUser makeUser(string_view path) {
  return make_holder<IUserImpl, IUser>(path);
}
}

TH_EXPORT_CPP_API_makeUser(makeUser);



void sendMessage(::user::weak::IUser a) {
    string_view user_email = a->getEmail();
    std::cout << "Welcome " << a->getEmail() << std::endl;
  }
 ：：是作用域：
 参数类型解析
1. :: 的作用
全局命名空间：最前面的 :: 表示全局命名空间
多级命名空间：user::weak 是嵌套的命名空间层次
类型名称：IUser 是在 user::weak 命名空间中定义的接口类型

weak 命名空间的可能含义
在 C++ 中，weak 常与智能指针（如 std::weak_ptr）相关，表示弱引用。推测 user::weak::IUser 可能是：

IUser makeUser(string_view path) {
  return make_holder<IUserImpl, IUser>(path);
}
make_holder是创建多态对象
union NullableValue {
    sValue: String;
    iValue: i32;
    @undefined uValue;
    @null nValue;
}

function makeNullableValue(tag: i32): NullableValue;
这段代码定义了一个名为 NullableValue 的联合类型（union），以及一个用于创建该类型实例的工厂函数。联合类型是一种特殊的数据结构，它允许在相同的内存位置存储不同类型的数据，但同一时间只能使用其中一个成员。
union联合体
联合类型的内存布局
1. 内存占用
联合的大小取决于其最大成员的大小
一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其它成员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员
类的某些特性对union同样适用，但并非所有特性都如此：
union不能含有引用类型的成员，union的成员可以是绝大多数类型。在C++11标准中，含有构造函数或析构函数的类类型也可以作为union的成员类型
union可以为其成员指定public、protected、private等标记。默认情况下union的成员都是公有的
union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其它类，也不能作为基类使用，所以在union中不能含有虚函数
匿名union不能定义在全局作用域中.
匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。
class Token
{
public:
Token() :tok(INT), ival(0) {}
Token(const Token &t) :tok(t.tok) { copyUnion(t); }
Token &operator=(const Token&);
~Token() {
if (tok == STR)
sval.~string();
}
//下面的赋值运算符负责设置union的不同成员
Token &operator=(char);
Token &operator=(int);
Token &operator=(double);
Token &operator=(const std::string&);
private:
enum { INT, CHAR, DBL, STR }tok;
//匿名union
union {
char cval;
int ival;
double dval;
std::string sval;
};
void copyUnion(const Token&);
};
核心设计思路
联合的特殊性质：
所有成员共享同一块内存（大小为最大成员的大小）
同一时间只能存储一个成员的值
不自动管理非 POD 类型（如std::string）的生命周期
内存管理挑战：
当存储std::string时，必须手动调用构造函数和析构函数
赋值时需要确保正确销毁旧值并构造新值
类型安全机制：
使用枚举tok作为判别式（tag），记录当前存储的类型
通过私有成员函数copyUnion确保安全复制


POD类型：
// POD类型
struct PodStruct {
    int x;
    double y;
};

// 非POD类型
struct NonPod {
    std::string s;  // 非POD成员
    virtual void func() {}  // 虚函数
};
operator运算符重载
运算符	重载形式示例
赋值	T& operator=(const T&);
加法	T operator+(const T&) const;
下标	T& operator[](size_t index);
函数调用	void operator()(args...);
输入	friend std::istream& operator>>(std::istream&, T&);
输出	friend std::ostream& operator<<(std::ostream&, const T&);

虚函数：virtual
纯虚函数：
定义：声明为纯虚的虚函数，没有实现
语法：virtual 返回类型 函数名(参数列表) = 0;
class Base {
public:
    virtual void pureVirtualFunc() = 0;  // 纯虚函数
};
特性	普通函数	虚函数	纯虚函数
关键字	无	virtual	virtual + = 0
是否可在基类实现	必须实现	必须实现	不能实现（仅声明）
是否构成多态	否	是	是
能否实例化基类	可以	可以	不可以（抽象类）
派生类是否必须重写	否	否（但建议重写）	是（否则派生类也为抽象类）
调用方式	静态绑定（编译时确定）	动态绑定（运行时确定）	动态绑定（通过派生类调用）


内存布局差异
1. 普通函数
类对象不包含函数指针
函数地址在编译时确定
2. 虚函数
类对象包含一个虚函数表指针（vptr）
虚函数表（vtable）存储虚函数地址
调用虚函数时，通过 vptr 和 vtable 动态查找函数地址
3. 纯虚函数
基类的虚函数表中对应项为未定义（通常为 0）
派生类必须实现纯虚函数，否则无法实例化


int a,b;
int &r = a;
int &r = b; //错误，不可更改原有的引用关系
引用 r 已被初始化为 a 的别名，无法重新绑定到 b
float &rr = b; //错误，引用类型不匹配
cout<<&a<<&r<<endl; //变量与引用具有相同的地址。
int &ra = r; //可对引用更次引用，表示 a 变量有两个别名，分别是r 和ra

引用与指针区别
引用 vs 指针
特性	引用（Reference）	指针（Pointer）
必须初始化	✅ 定义时必须绑定对象	❌ 可先声明后赋值
能否更改绑定	❌ 一旦绑定无法更改	✅ 可随时指向其他对象
空值允许	❌ 不可为空	✅ 可赋值为 nullptr
语法	使用 & 声明，操作同普通变量	使用 * 解引用，& 获取地址

关键区别：指针是 “值”，引用是 “别名”
对比维度	指针（Pointer）	引用（Reference）
内存存储	有独立内存，存储 “地址值”（是一个值）	无独立内存，与被引用变量共享地址（不是值）
初始化	可先定义后赋值（甚至指向空）	必须在定义时初始化，且不能指向空
可修改性	可改变指向的变量（值可修改）	一旦绑定，无法更改指向的变量
操作方式	需用 * 解引用才能访问目标变量	直接操作，无需解引用
地址含义	&p 是指针自身的地址，p 是指向的地址	&r 是被引用变量的地址（无自身地址）


int a;
int* p = &a;
int*& rp = p; // ok
int& r = a;
int&& rr = r; // error

new/delete 是关键字，效率高于 malloc 和 free.

宏函数：
#define 宏名(参数列表) 替换文本

inline函数
在 C++ 中，内联函数（Inline Function） 是一种向编译器建议直接将函数体代码插入调用处的机制，从而避免函数调用的开销
inline 返回类型 函数名(参数列表) {
    // 函数体
}

类型转换
static_cast<T>
int a = 10;
double b = static_cast<double>(a) / 3;  // 显式转换为double，避免整数除法

常类型转换：目标类类型只能是指针或引用
const_cast
const int m = 4444;
func(const_cast<int&>(m));
用来移除对象的常量性(cast away the constness)使用 const_cast 去除const 限定的目的不是为了修改它的内容，使用 const_cast 去除 const 限定，通常是为了函数能够接受这个实际参数。

dynamic_cast<目标类型> (标识符)


#ndef之类的作用
这段代码是 C++ 中典型的 ** 头文件保护（Header Guard）** 机制，用于防止头文件被重复包含，避免因重复定义导致的编译错误。

头文件保护的核心目的是避免类 / 函数的重复定义。若没有 #ifndef 保护，多次包含头文件会导致编译器看到重复的类定义：
cpp
运行
// 无保护时，重复包含的结果
class A { /* ... */ };  // 第一次定义
class A { /* ... */ };  // 第二次定义 → 编译错误：重复定义

A::AA obj;  
// 在栈上创建对象
A::AA obj;  // 在栈上创建对象
内存分配：对象直接在栈上分配，无需手动管理内存。
生命周期：对象在作用域结束时自动销毁（调用析构函数）。
使用方式：通过对象名直接访问成员（. 操作符）：
obj.someMethod();  // 调用成员方法
推上创建对象：
A::AA* obj = new A::AA();  // 在堆上创建对象，返回指针
内存分配：对象在堆上动态分配，需手动通过 delete 释放内存。
生命周期：对象直到 delete 被调用才销毁，否则会导致内存泄漏。
使用方式：通过指针访问成员（-> 操作符）：
obj->someMethod();  // 调用成员方法
delete obj;         // 手动释放内存

字符串字面量会自动在末尾添加一个 ** 空字符'\0'** 作为结束标志
sizeof和strlen函数的主要区别在于它们计算的内容不同。
 sizeof计算类型或对象所占用的字节大小，而strlen计算字符串的长度（不包括结尾的\0字符）。
 相比之下，sizeof的功能要强大得多，因为其可以作用与类型 变量 常量 表达式，而strlen只能作用于指针
 - sizeof计算的是类型或对象的大小，它是一个编译时运算符，所以在编译时就可以确定大小。
 - strlen计算的是字符串的长度，它是一个标准库函数，需要在运行时计算。


拷贝构造函数
类名(const 类名 & another)
拷贝构造体

struct Student
{
	char* name;
	int age;
};
以下方式正确：
Student stu;
stu.name = (char*)malloc(100);
// 写法1：不使用括号
Student* ps1 = new Student;     // name和age的值未初始化（随机值）

// 写法2：使用括号
Student* ps2 = new Student();   // name被初始化为nullptr，age被初始化为0
初始化规则详解

（1）new Student（无括号）
行为：执行默认初始化（Default Initialization）。
效果：
指针类型成员（如 char* name）的值为未初始化（随机垃圾值）。
基本类型成员（如 int age）的值为未初始化（随机垃圾值）。
风险：直接使用未初始化的指针或数值可能导致程序崩溃或未定义行为。
（2）new Student()（带括号）
行为：执行值初始化（Value Initialization）。
效果：
指针类型成员（如 char* name）被初始化为 nullptr。
基本类型成员（如 int age）被初始化为 0。
安全性：避免了使用未初始化值的风险，更推荐。



使用安全复制
strcpy_s

赋值运算符重载(Operator=)
类名
{
类名& operator=(const 类名& 源对象)
拷贝体
}
eg:
class A
{
A& operator=(const A& another)
{
//函数体
return *this;
}
};

A foo(A& a)
{
    cout << "in foo :" << (void*)&a << endl;
    return a;
}
打印a的引用地址，同时返回a,会默认调用a的拷贝构造函数
拷贝构造函数（Copy Constructor） 是一种特殊的构造函数，用于创建一个新对象，该对象是另一个同类型对象的副本。它在以下场景中自动调用：

对象初始化：A b(a); 或 A b = a;
函数按值传递对象：void func(A obj)
函数返回对象：return obj;

class NonCopyable {
public:
    NonCopyable() = default;
    NonCopyable(const NonCopyable&) = delete;  // 禁止拷贝
    NonCopyable& operator=(const NonCopyable&) = delete;  // 禁止赋值
};
=delete就是禁止某方法

当使用智能指针后std::unique_ptr 的核心特性是独占所有权，即同一时间只能有一个指针指向对象。因此，默认情况下，包含 std::unique_ptr 的类会自动禁用拷贝构造函数和赋值运算符：


返回栈对象的引用，多用于产生串联应用。比如连等式。 栈对象是不可以返回引用的。除非，函数的调用者返回自身对象。

memset:
作用
内存初始化：将一段内存区域的值全部设置为指定的字节值。
原型：void* memset(void* ptr, int value, size_t num);
ptr：指向要填充的内存块的指针。
value：要设置的值（转换为 unsigned char）。
num：要填充的字节数。
int arr[10];
memset(arr, 0, sizeof(arr));  // 将数组所有元素置为0
注意：预留 '\0' 的位置
关系运算符重载
bool MyString::operator==(const MyString &other)
{
if(strcmp(this->_str,other._str) == 0)
return true;
else
return false;
}
bool MyString::operator>(const MyString &other)
{
if(strcmp(this->_str,other._str) > 0)
return true;
else
return false;
}
bool MyString::operator<(const MyString &other)
{
if(strcmp(this->_str,other._str) < 0)
return true;
else
return false;
}
strcmp比对函数

[]运算符重载
char & MyString::operator[])(int idx){
 return _str[idx];
}

// 非 const 版本：允许修改元素
返回类型& operator[](索引类型 index);

// const 版本：仅允许读取元素（用于 const 对象）
const 返回类型& operator[](索引类型 index) const;

// 常量成员函数（承诺不修改对象状态）
    int getValue() const { return value; }
若需要在常量成员函数中修改某个成员变量，可将其声明为 mutable

unistd.h
unistd.h 是 C 和 C++ 程序设计语言中提供对 POSIX 操作系统 API 的访问功能的头文件的名称。







今日收获
1.phone-x86-api模拟器安装，
2.HarmonyOS 鸿蒙Next 模拟器抓包：配合charles抓包：
https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs-V5/faqs-network-55-V5


time_t是时间戳类型,time是时间函数

时间格式化：
1.strftime格式化时间
2.setfill,setw拼接
3.snprintf

<iomanip>	提供输入 / 输出流的格式化工具，如 std::setw、std::setfill。
<sstream>	提供字符串流（std::ostringstream），用于将数据格式化为字符串。


system("cls"); // 清屏
获取当前时间：system_clock::now()
time_t t = std::chrono::system_clock::to_time_t(now);C++11 引入的时钟类型，表示系统实时时钟

通过指针关联节点：链表


静态方法可以且通常应该在类外实现，这是 C++ 的标准做法。只需确保：

在类内声明时使用 static 关键字。
在类外实现时不重复 static，但需指定类名和作用域解析符 ::。
静态成员变量需在类外单独初始化。



静态共享成员使用static const
static const void dis()
{
cout<<i<<endl;
}

函数指针：
void (*pf)(int) = func;  // 定义函数指针pf，指向函数func
    pf(10);                 // 通过函数指针调用func函数
void func(int a)
{
cout<<a<<endl;
}

指向类数据成员的指针
定义
<数据类型><类名>::*<指针名>
赋值&初始化
<数据类型><类名>::*<指针名>[=&<类名>::<非静态数据成员>]		


由于类不是运行时 存在的对象。因此，在使用这类指针时，需要首先指定类的一个对象，然后，通过对象来引用指针所指向的成员。
<类对象名>.*<指向非静态数据成员的指针>
<类对象指针>->*<指向非静态数据成员的指针>
成员函数指针必须通过对象实例或对象指针调用
class School
{
public:
	string tower;
	string lake;
	static string lib;
	void dis()
{
cout<<"name "<<name<<" num "<<num<<endl;
}
};

int main() {
	string School::* ps = &School::tower;
	
	void (Student::*pf)() = & Student::dis;
	(s.*pf)();
	(s2.*pf)();
	(ps->*pf)();
}

特性	普通函数指针	成员函数指针
定义语法	返回值类型 (*pf)(参数列表)	返回值类型 (类名::*pf)(参数列表)
绑定对象	不需要（直接调用全局函数）	必须通过对象或指针调用
调用操作符	pf(参数)	(对象.*pf)(参数) 或 (指针->*pf)(参数)
存储内容	函数的内存地址	函数在类中的相对偏移量（与对象类型绑定）
成员函数指针的核心价值在于实现动态方法调用，例如:
class Shape {
public:
    void draw() { cout << "Drawing shape" << endl; }
    void rotate() { cout << "Rotating shape" << endl; }
};

int main() {
    Shape s;
    void (Shape::*action)() = &Shape::draw;  // 动态选择方法
    (s.*action)();  // 输出：Drawing shape
    
    action = &Shape::rotate;  // 切换方法
    (s.*action)();  // 输出：Rotating shape
    return 0;
}

成员函数指针的核心价值在于实现动态方法调用
成员函数指针的核心价值在于实现动态方法调用
成员函数指针的核心价值在于实现动态方法调用

指向类静态成员的指针
#include <iostream>
using namespace std;
class A
{
public:
static void dis();
static int data;
};
void A::dis()
{
cout<<data<<endl;
}
int A::data = 100;
int main()
{
int *p = & A::data;
cout<<*p<<endl;
void (*pfunc)() = &A::dis;
pfunc();
return 0;
}

使用转义序列 \x20
ASCII 码中，空格的十进制值是 32（十六进制为 0x20），因此可以用转义序列表示：
cout << data<<'\x20' << num << endl;


pow()幂函数

采用类的机制后实现了数据的隐藏与封装，类的数据成员一般定义为私有成员，成员函数一般定义为公有的，依此提供类与外界间的通信接口。但是，有时需要定义一些函数，这些函数不是类的一部分，但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该类的友元函数。除了友元函数外，还有友元类，两者统称为友元。友元的作用是提高了程序的运行效率（即减少了类型和安全性检查及调用的时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。
友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类
友元目的本质，是让其它不属于本类的成员(全局函数，其它类的成员函数)，成为类的成员而具备了本类成员的属性

friend 类型 函数名(形式参数);
在类中用 friend 关键字声明的非成员函数，它可以访问该类的私有和保护成员。
语法：
cpp
运行
class MyClass {
    friend 返回类型 函数名(参数列表);  // 友元函数声明
};

关键点：
友元函数不是类的成员，但可以访问类的私有成员。
声明位置：友元声明可以放在类的任何位置（public/private/protected），效果相同。
调用方式：像普通函数一样调用，无需通过对象。

友元类（Friend Class）
基本概念
定义：如果类 B 是类 A 的友元类，则类 B 的所有成员函数都可以访问类 A 的私有和保护成员。

class A {
    friend class B;  // 声明 B 是 A 的友元类
};
class Account {
private:
    string owner;
    double balance;
public:
    Account(string name, double bal) : owner(name), balance(bal) {}
    
    // 声明友元类
    friend class BankSystem;
};

class BankSystem {
public:
    // 可以访问 Account 的私有成员
    static void transfer(Account& from, Account& to, double amount) {
        from.balance -= amount;
        to.balance += amount;
    }
    
    static void showBalance(const Account& acc) {
        cout << acc.owner << " 的余额: " << acc.balance << endl;
    }
};
友元的优缺点
优点：
提高灵活性：在特定场景下允许高效的数据共享。
优化性能：避免频繁调用公共接口的开销。
缺点：
破坏封装性：暴露了类的实现细节，违反面向对象的设计原则。
降低可维护性：友元关系增加了类之间的耦合度，修改一个类可能影响多个友元。

注意事项
(1) 友元关系不能被继承。
(2) 友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，类A 不一定是类B的友元，要看在类中是否有相应的声明。
(3) 友元关系不具有传递性。若类 B 是类 A 的友元，类 C 是 B 的友元，类C 不一定是类 A 的友元，同样要看类中是否有相应的申明

运算符重载
返值类型 operator 运算符名称(形参表列)
{
重载实体;
}
重载规则
（1）C++不允许用户自己定义新的运算符，只能对已有的 C++运算符进行重载。例如，有人觉得 BASIC 中用“* *”作为幂运算符很方便，也想在C++中将“* *”定义为幂运算符，用“3* *5”表示 3
5，这是不行的。
（2）C++允许重载的运算符
C++中绝大部分运算符都是可以被重载的
不能重载的运算符只有 4 个：
. 成员运算符
.* 成员对象选择符
:: 域解析运算符
?: 条件运算符
sizeof 类型大小运算符


友元重载，new,delete重载，


用类型转换构造函数进行类型转换
class 目标类
{
目标类(const 源类 & 源类对象引用)
{
根据需求完成从源类型到目标类型的转换
}
}


explicit 关键字的意义
在 C++ 里，explicit关键字主要用于修饰单参数构造函数或者除第一个参数外其他参数都有默认值的多参数构造函数，其核心作用是禁止隐式类型转换，仅允许显式类型转换。
std::unique_ptr<int> ptr = new int(42);  // 错误：禁止隐式转换
std::unique_ptr<int> ptr(new int(42));   // 正确：显式构造

类型转化函数格式
class 源类{
operator 转化目标类(void)
{
根据需求完成从源类型到目标类型的转换
}
}



class Point2D
{
public:
Point2D(int x,int y)
:_x(x),_y(y){}
operator Point3D();
。。。
}
Point2D::operator Point3D()
{
return Point3D(_x,_y,0);
}

仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了
在 C++ 中，仿函数（Functor） 也被称为函数对象（Function Object），是一种特殊的对象，其行为类似于函数。它的核心作用是将函数封装成对象，从而在需要函数作为参数的场景中使用，同时还能携带额外的状态
2. 携带状态
仿函数可以包含成员变量，用于存储状态信息，这是普通函数无法做到的。
class 类名
{
返值类型 operator()(参数类型)
函数体
}
主要应用于 STL 和模板

for_each参数详解：
for_each(InputIt first, InputIt last, UnaryFunction f);
函数对象参数 f
类型：一元函数对象（UnaryFunction）
作用：对范围内的每个元素调用该函数对象。
要求：
函数对象必须能够接受一个与迭代器所指向元素类型兼容的参数。
函数对象可以返回一个值，但这个返回值会被忽略。
函数对象可以是：
普通函数指针。
函数对象（仿函数）。
Lambda 表达式（C++11 及以后）。

std::transform函数，有用

void* 的语义
通用指针类型：void* 是一种特殊的指针类型，它可以指向任意类型的数据，但不能直接解引用（因为编译器不知道其具体类型）。
内存分配的通用接口：在 C++ 中，内存分配函数（如 malloc、new）通常返回 void*，表示 “一块原始内存”，需要通过类型转换将其转换为具体类型


智能指针
auto_ptr<A> p (new A);
p->func(); //两种访问方式
(*p).func();

根据 C++ 标准（如 C++17 [expr.delete]/2），delete 的行为定义为：
如果对象是类类型（class type），则调用其析构函数。
调用 operator delete 释放内存。

 与构造过程的对称性
对象的创建和销毁遵循资源分配与释放的对称性：
构造过程：先分配内存（operator new），再调用构造函数。
销毁过程：先调用析构函数，再释放内存（operator delete）。
这种对称性避免了资源泄漏，符合 RAII（资源获取即初始化）原则


size_t：是无符号整形数据，通常为对象大小或数组引用。
继承、派生类的声明：
class 派生类名：[继承方式] 基类名
{
派生类成员声明；
};

派生类构造函数的语法：
派生类名::派生类名（参数总表）
：基类名（参数表）,内嵌子对象（参数表）
{
派生类新增成员的初始化语句; //也可出现地参数列表中
}
Doctor::Doctor(string sn, int in, char cs, float fs, string st, int iy, int im, int id)
	:Graduate(sn, in, cs, fs), birth(iy, im, id), title(st)
{
}
注：
构造函数的初始化顺序并不以上面的顺序进行，而是根据声明的顺序初始化。如果基类中没有默认构造函数(无参)，那么在派生类的构造函数中必须显示调用基类构造函数，以初始化基类成员。

派生类的拷贝构造
派生类::派生类(const 派生类& another)
:基类(another),派生类新成员(another.新成员)
{
}


typeid(expression)  // 返回一个 const std::type_info& 引用
只有基类包含虚函数时，typeid 才能识别动态类型（即实际指向的对象类型）。否则，typeid 仅返回指针 / 引用的静态类型。
void printType(Shape* s) {
    if (typeid(*s) == typeid(Circle)) {
        std::cout << "Circle" << std::endl;
    } else if (typeid(*s) == typeid(Square)) {
        std::cout << "Square" << std::endl;
    }
}

基类的private成员
private成员完全禁止被派生类访问，无论派生类以何种方式继承（public/protected/private）：
派生类的成员函数无法直接访问基类的private成员。
派生类对象无论是在内部还是外部，都不能访问基类的private成员。


基类的protected成员
protected成员可以被派生类访问，但有严格的访问范围限制：
允许的访问场景：
派生类的成员函数（包括构造函数、析构函数）可以直接访问基类的protected成员。
派生类的对象在派生类内部（如成员函数中），可以通过自身对象或派生类对象访问基类的protected成员。
禁止的访问场景：
派生类对象在外部（如main函数中）无法访问基类的protected成员（与private类似，对外不可见）。
派生类不能通过基类对象访问其protected成员（只能通过 “自身类型的对象” 访问）。

多继承：
派生类名::派生类名（参数总表）
：基类名 1（参数表 1），基类名（参数名 2）....基类名 n（参数名n），内嵌子对象 1（参数表 1），内嵌子对象 2（参数表 2）....内嵌子对象 n（参数表n）{
派生类新增成员的初始化语句；
}

虚继承：virtual
    Base
   /    \
Derived1  Derived2
   \    /
    Final
class Y:virtual public M
虚继承（Virtual Inheritance）是 C++ 中用于解决 ** 菱形继承（钻石问题）** 的一种技术。当一个派生类通过多条路径继承同一个基类时，虚继承可以确保该基类只存在一份实例，从而避免数据冗余和访问歧义。


多态：136：
浅析多态的意义
如果有几个上似而不完全相同的对象，有时人们要求在向它们发出同一个消息时，它们的反应各不相同，分别执行不同的操作。这种情况就是多态现象。
例如，甲乙丙 3 个班都是高二年级，他们有基本相同的属性和行为，在同时听到上课铃声的时候，他们会分别走向 3 个不同的教室，而不会走向同一个教室。
同样，如果有两支军队，当在战场上听到同种号声，由于事先约定不同，A 军队可能实施进攻，而 B 军队可能准备 kalalok。
又如在 winows 环境下，用鼠标双击一个对象（这就是向对象传递一个消息），如果对象是一个可执行文件，则会执行此程序，如果对象是一个文本文件，由会启动文本编辑器并打开该文件。
C++中所谓的多态(polymorphism)是指，由继承而产生的相关的不同的类，其对象对同一消息会作出不同的响应。
多态性是面向对象程序设计的一个重要特征，能增加程序的灵活性。可以减轻系统升级,维护,调试的工作量和复杂度.

父类（Parent Class） = 基类（Base Class）：即被继承的类，这里是 Shape。在 UML（统一建模语言）中，基类称为 超类（Superclass），派生类称为 子类（Subclass）
子类（Child Class） = 派生类（Derived Class）：即继承其他类的类，这里是 Circle

多态形成的条件
8.3.1.多态
8.3.1.1.静多态
前面学习的函数重载，也是一种多态现象，通过命名倾轧在编译阶段决定，故称为静多态。
8.3.1.2.动多态
动多态，不是在编译器阶段决定，而是在运行阶段决定，故称为动多态。动多态行成的条件如下:
1，父类中有虚函数。
2，子类 override(覆写)父类中的虚函数。
3，通过己被子类对象赋值的父类指针或引用，调用共用接口。


虚函数
class 类名
{
virtual 函数声明;
}
虚函数小结
1，在基类中用 virual 声明成员函数为虚函数。类外实现虚函数时，不必再加virtual.
2，在派生类中重新定义此函数称为覆写，要求函数名，返值类型，函数参数个数及类型全部匹配。并根据派生类的需要重新定义函数体。
3，当一个成员函数被声明为虚函数后，其派生类中完全相同的函数（显示的写出）也为虚函数。 可以在其前加 virtual 以示清晰。
4，定义一个指基类对象的指针，并使其指向其子类的对象，通过该指针调用虚函数，此时调用的就是指针变量指向对象的同名函数。
5，子类中的覆写的函数，可以为任意访问类型，依子类需求决定

当一个类包含虚函数时，其析构函数通常也应该声明为 virtual。这是为了确保在通过基类指针删除派生类对象时，能正确调用派生类的析构函数，防止内存泄漏。
基类的虚函数不要求派生类必须重写，是否重写取决于业务需求

纯虚函数
格式
class 类名
{
virtual 函数声明 = 0;
}
纯虚函数小结
1.含有纯虚函数的类，称为抽象基类，不可实列化。即不能创建对象，存在的意义就是被继承，提供族类的公共接口，java 中称为 interface。
2. 纯虚函数只有声明，没有实现，被“初始化”为 0。
3. 如果一个类中声明了纯虚函数，而在派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数，派生类仍然为纯虚基类。
8.3.6.含有虚函数的析构
含有虚函数的类，析构函数也应该声明为虚函数。在 delete 父类指针的时候，会调用子类的析构函数，实现完整析构。
8.3.7.若干限制
1)只有类的成员函数才能声明为虚函数
虚函数仅适用于有继承关系的类对象，所以普通函数不能声明为虚函数。2)静态成员函数不能是虚函数
静态成员函数不受对象的捆绑，只有类的信息。
3)内联函数不能是虚函数
4)构造函数不能是虚函数
构造时，对象的创建尚未完成。构造完成后，才能算一个名符其实的对象。5)析构函数可以是虚函数且通常声明为虚函数。



C++中有一种设计原则叫依赖倒置。也是基于多态的。
1. 高层模块不应该依赖低层模块，两者都应该依赖抽象。
2. 抽象不应该依赖细节，细节应该依赖抽象。



‌std::move是C++11引入的一个函数模板，用于将对象转换为右值引用，从而触发移动语义而非拷贝语义，以提高程序性能‌。它通过资源所有权转移而非深拷贝来优化容器操作、函数返回值等场景
 explicit OrderService(std::unique_ptr<PaymentMethod> method)
     : paymentMethod(std::move(method)) {
 }
 为什么需要 std::move？
std::unique_ptr 禁止拷贝：由于 unique_ptr 表示独占所有权，直接拷贝会导致编译错误。
std::move 触发移动构造函数：通过 std::move 将左值转换为右值引用，调用 unique_ptr 的移动构造函数，实现所有权的安全转移。

std::move 的实现原理（简化版）
std::move 的作用：将一个对象强制转换为右值引用，从而允许对其调用移动操作。
cpp
运行
template <typename T>
typename std::remove_reference<T>::type&& move(T&& t) noexcept {
    // 通过 static_cast 将 t 转换为右值引用
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}


模板参数 T&& 是万能引用（Universal Reference），可以接受左值或右值。
std::remove_reference<T>::type 用于去除 T 的引用属性（例如将 int& 转为 int）。
static_cast 最终将输入转换为 T 类型的右值引用（T&&）。
std::unique_ptr 的核心特性是独占资源所有权：同一时间只能有一个 unique_ptr 指向某个资源。当所有权转移时，原指针会被置空。
如：
 auto payment = std::make_unique<Alipay>();
 OrderService orderService(std::move(payment));调用构造函数

explicit OrderService(std::unique_ptr<PaymentMethod> method)
    : paymentMethod(std::move(method)) {}

1. 参数 method 的值类别
method 是构造函数的局部变量，虽然它的类型是 std::unique_ptr<PaymentMethod>，但作为变量，它本身是左值（因为有名字、可取地址）。
2. 为什么需要 std::move(method)？
成员变量 paymentMethod 的类型是 std::unique_ptr<PaymentMethod>。
要将局部变量 method 的资源转移给 paymentMethod，必须再次使用 std::move 将左值 method 转换为右值引用。
否则，若直接写 paymentMethod(method)，会尝试调用 unique_ptr 的拷贝构造函数（但 unique_ptr 禁止拷贝），导致编译错误。

在 C++ 中，std::function 不是函数，而是一个通用的多态函数包装器（类型擦除的函数对象）。它可以存储、复制和调用任何可调用对象（如普通函数、成员函数、Lambda 表达式、函数对象等），只要这些对象的调用签名（参数类型和返回值）匹配。


引用传递
 void registerPaymentType(const string& type,
     function<unique_ptr<PaymentMethod>()> factory) {// 工厂函数
     factories[type] = factory;// 存入哈希表
 }

运行时类型信息(RTTI)
typeid dynamic_cast 是 C++ 运行时类型信息 RTTI(run time type identificaiton）重要组成部分。运行时信息，来自于多态，所以以下运算符只用于基于多态的继承体系中。8.5.1.typeid
运算符 typeid 返回包含操作数数据类型信息的 type_info 对象的一个引用，信息中包括
作者：王桂林 技术交流:qq329973169

数据类型的名称，要使用 typeid,程序中需要包含头文件<typeinfo>。其中 type_info 重载了操作符==, !=,分别用来比较是否相等、不等，函数name()返回类型名称。type_info 的拷贝和赋值均是私有的，故不可拷贝和赋值。
常用于返回检查,调试之用

typedef
typedef void (*Func)();写法 using Func = void (*)();  // 与 typedef 完全等价
声明函数指针
typedef：声明一个类型别名（而非定义变量）。
void (*Func)()：定义一个函数指针类型。
Func：类型名（可自定义，如 MyFunctionPtr）。
*：表示这是一个指针。
()：参数列表为空，表示该函数不接受参数。
void：返回值类型为 void
 与 std::function 的对比
特性	函数指针 (void (*)())	std::function<void()>
类型	原始指针类型	类模板（函数对象包装器）
可调用对象类型	只能指向普通函数或静态成员函数	可存储普通函数、Lambda、成员函数等
状态存储	不能存储状态（如 Lambda 捕获的变量）	可存储状态（类型擦除）
空值处理	可为 nullptr	可通过 empty() 或 bool() 判断
性能	接近直接调用（无开销）	有少量开销（类型擦除、堆分配）
语法复杂度	较复杂（需处理指针和解引用）	更简洁（类似普通函数调用）
std::function 是 C++11 引入的更高级抽象，提供类型安全和更大的灵活性，优先推荐使用，在functional库中
在 C++ 中，<functional> 是标准库的一个重要组件，提供了一系列与函数对象、函数式编程和回调机制相关的工具。它主要包含以下核心功能：
1. 函数对象包装器
std::function
作用：通用的多态函数包装器，可存储、复制和调用任何可调用对象（普通函数、Lambda、成员函数等）。
std::bind 和 std::placeholders
作用：用于绑定函数参数或调整参数顺序，生成一个新的可调用对象。
预定义的函数对象
<functional> 提供了一系列常用的函数对象，如算术、比较、逻辑运算等：
#include <functional>
#include <iostream>

// 普通函数
int add(int a, int b) { return a + b; }

// Lambda 表达式
auto multiply = [](int a, int b) { return a * b; };

// 使用 std::function 存储不同类型的可调用对象
std::function<int(int, int)> op;

op = add;             // 存储普通函数
std::cout << op(3, 4) << std::endl;  // 输出: 7

op = multiply;        // 存储 Lambda
std::cout << op(3, 4) << std::endl;  // 输出: 12

std::bind 和 std::placeholders
作用：用于绑定函数参数或调整参数顺序，生成一个新的可调用对象。
#include <functional>
#include <iostream>

using namespace std::placeholders;  // 占位符命名空间

int divide(int a, int b) { return a / b; }

// 绑定第一个参数为 10，生成新的一元函数
auto divideByTen = std::bind(divide, 10, _1);
std::cout << divideByTen(2) << std::endl;  // 输出: 5（10/2）

// 交换参数顺序
auto reverseDivide = std::bind(divide, _2, _1);
std::cout << reverseDivide(10, 2) << std::endl;  // 输出: 0.2（2/10）



typecast
8.5.2.1.static_cast
在一个方向上可以作隐式转换的，在另外一个方向上可以作静态转换。发生在编译阶段，不保证后序使用的正确性。
8.5.2.2.reinterpreter_cast
既不在编译器期也不在运行期进行检查，安全性完全由程序员决定。
8.5.2.3.dynamic_cast
dynamic_cast 一种运行时的类型转化方式,所以要在运行时作转换判断。检查指针所指类型，然后判断这一类型是否与正在转换成的类型有一种 “is a”的关系，如果是，dynamic_cast 返回对象地址。如果不是，dynamic_cast 返回 NULL。dynamic_cast 常用多态继承中，判断父类指针的真实指向。
dynamic_cast 禁止跨无关类转换

dynamic_cast 的核心作用是 在继承体系中安全地向下转型（或跨转型），它会在运行时检查指针指向的 实际对象类型 是否与目标类型兼容：

当 pa 指向 B 对象时，dynamic_cast<B*>(pa) 成功，因为实际类型匹配；
当尝试 dynamic_cast<C*>(pa) 时，运行时会发现 pa 指向的是 B 对象，而 B 和 C 无继承关系，因此判定转换不合法，返回 nullptr。

三种转换的核心区别
转换方式	检查时机	安全性	适用场景
dynamic_cast	运行时	最安全（失败返回空）	多态场景下的向下转换（如基类转派生类）
static_cast	编译期	中等（依赖程序员判断）	相关类型转换（如数值转换、向上转换）
reinterpret_cast	无检查	最不安全（仅重解释）	底层二进制兼容场景（如硬件交互）


函数模板
template<typename/class 类型参数表>
返回类型 函数模板名(函数参数列表)
{
函数模板定义体
}

类模板定义
template<typename T>
class Stack
{
}template<typename T>
class Stack
{
public:
Stack(int size)
{
space = new T[size];
top = 0;
}
}
.类外定义函数
template<typename T>
void Stack<T>::push(T data)
{
space[top++] = data;
}
在 C++ 中，类模板的成员函数可以直接访问类的私有成员（如 space 和 top），这是因为 模板实例化后的成员函数属于该类的具体类型。即使这些成员函数在类外定义，它们仍然是类的一部分，因此具有访问私有成员的权限。
模板类的成员函数能够访问类的私有成员，原因在于：
成员函数的访问权限：类的成员函数（无论是否为模板）都可以访问类的私有成员。
模板实例化的结果：模板成员函数在实例化后，成为具体类的一部分，因此享有该类的访问权限。

模板定义很特殊。由 template<…> 处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义,文件后缀为.hpp。




get 和 getline 最大的区别就是，get 遇到界定符时，停止执行，但并不从流中提取界定符，再次调用会遇到同一个界定符，函数将立即返回，不会提取输入。getline 则不同，它将从输入流中提供界定符，但伤然不会把它放到缓冲区中。


文件流：190

异常：
异常处理的注意事项
（1）异常匹配规则
按顺序匹配：多个 catch 块按从上到下的顺序匹配。
基类优先：若有多个 catch 块，基类异常应放在子类异常之后，否则子类异常会被基类捕获


try
{
被检查的语句
}
catch(异常信息类型 [变量名])
{
进行异常处理的语句
}
try{}
catch(double){}
catch(int){}
catch(char){}
catch(float){}

捕获所有异常：
try {
    // 可能抛出任何异常的代码
}
catch (...) {
    cout << "捕获到未知异常" << endl;
    // 无法获取异常对象的具体信息
}

noexcept:不会执照异常
void func() noexcept {
    // 此函数不会抛出异常
}
栈自旋：
异常被抛出后，从进入 try 块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋(unwinding)。而堆上的空间，则会泄漏。

stl:207

boost,stl,c11


定义了文件流对象后，就可以利用其成员函数 open（）打开需要操作的文件，该成员函数的函数原型为：
void open（const unsigned char *filename,int mode,int access=filebuf:openprot）；其中：filename 是一个字符型指针，指定了要打开的文件名；mode 指定了文件的打开方式，其值如下表所示；access 指定了文件的系统属性，取默认即可：
mode ：在 ios 类中定义的文件打开方式文件打开方式 值 含 义
ios::in 0x01 以输入（读）方式打开文件，若文件不存在则报错。
ios::out 0x02 以输出（写）方式打开文件, 若文件不存则创建。
ios::app 0x08 打开一个文件使新的内容始终添加在文件的末尾，若文件不存在，则报错。ios::trunc 0x10 若文件存在，则清除文件所有内容；若文件不存在，则创建新文件。ios::binary 0x80 以二进制方式打开文件，缺省时以文本方式打开文件。
ios::nocreate 0x20 打开一个已有文件，若该文件不存在，则打开失败。
ios::noreplace 0x40 若打开的文件已经存在，则打开失败。

说明：
1) 在实际使用过程中，可以根据需要将以上打开文件的方式用“|”组合起来。如：ios::in|ios::out 表示以读/写方式打开文件
ios::in|ios:: binary 表示以二进制读方式打开文件ios::out|ios:: binary 表示以二进制写方式打开文件ios::in|ios::out|ios::binary 表示以二进制读/写方式打开文件2) 如果未指明以二进制方式打开文件，则默认是以文本方式打开文件。3) 对于 ifstream 流， mode 参数的默认值为 ios::in，
对于 ofstream 流，mode 的默 认值为 ios::out|ios::trunc,
对于 fstream 流， mode 的默认值为 ios::int|ios::out|ios::app
4) 也可以通过，构造函数打开文件。
5) 出错处理是通过，对类对象进行判断的。若文件打开成功，返回1，否则返回0

缓冲区;
在 C++ 标准库中，ifstream 对象本身并没有一个固定大小的 “缓冲区”，但它会通过 streambuf 类间接管理输入缓冲区。这个缓冲区的大小和位置取决于具体的实现细节，下面详细说明：
1. 缓冲区的实现机制
ifstream 继承自 istream，而 istream 通过一个关联的 streambuf 对象来管理底层的输入缓冲区。这个 streambuf 通常由标准库在后台自动创建和管理。
例如，当你调用 ifs.getline() 时：
ifs 首先检查缓冲区中是否有足够的数据。
如果缓冲区为空或数据不足，ifs 会从文件中读取一批数据到缓冲区（由 streambuf 负责）。
然后从缓冲区中提取所需的数据（如一行内容）。
2. 缓冲区的大小
缓冲区的大小没有统一标准，取决于具体的编译器和系统实现：

GCC/libstdc++：默认缓冲区大小通常为 4096 字节（4KB），这与操作系统的页大小一致。
Clang/libc++：实现类似，可能也为 4KB。
Windows/Visual Studio：默认大小可能不同，但通常也是几 KB。

文件读的过程中：
eof()
如果读文件到达文件末尾，返回 true。
bad()
如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。
fail()
除了与 bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。或是遇到 eof。good()
这是最通用的：如果调用以上任何一个函数返回 true 的话，此函数返回false 。
clear()
标识位一旦被置位，这些标志将不会被改变，要想重置以上成员函数所检查的状态标志，你可以使用成员函数 clear()，没有参数。比如:通过函数移动文件指针，并不会使eofbit
自动重置。


通常讨论的是栈内存（Stack Memory） 和堆内存（Heap Memory），二者是程序运行时内存分配的两种主要方式，核心区别体现在分配方式、管理机制、用途等方面。以下是详细对比：
一、分配与释放方式
1. 栈内存（Stack）
分配方式：自动分配，由编译器在程序运行时根据函数调用、局部变量定义等自动完成。
例如：函数内定义的局部变量（int a = 10;）、函数参数、返回地址等，都会被压入栈中。
释放方式：自动释放，遵循 “先进后出（LIFO）” 原则。
当函数执行结束时，其内部的局部变量、参数等占用的栈内存会被自动释放，无需程序员手动操作。
2. 堆内存（Heap）
分配方式：手动分配，由程序员通过特定函数（如 C 中的malloc、C++ 中的new、Python 中的动态对象创建等）主动申请。
例如：int* p = new int[10]; 会在堆中分配一块能存储 10 个 int 的内存，并将地址赋值给指针p。
释放方式：手动释放（部分语言有自动回收机制），需程序员通过free（C）、delete（C++）等操作主动释放，否则会导致内存泄漏。
注意：Java、Python 等语言通过垃圾回收（GC）自动管理堆内存，无需手动释放，但底层仍属于堆分配。
二、内存大小与生命周期
特性	栈内存（Stack）	堆内存（Heap）
大小限制	通常较小（取决于系统和编译器，一般几 MB）	较大（可接近系统可用内存，通常 GB 级别）
生命周期	与所在作用域绑定（如函数执行期间）	由程序员控制（从分配到释放，跨作用域）
三、访问效率与碎片
1. 栈内存
效率高：栈是连续的内存块，分配时只需移动栈指针（类似数据结构中的栈操作），无需复杂的内存查找，访问速度极快。
无碎片：内存分配和释放严格遵循 LIFO，不会产生内存碎片。
2. 堆内存
效率较低：堆是不连续的内存块，分配时需要操作系统在空闲内存中查找合适大小的块，耗时较长；释放后可能产生碎片。
可能产生碎片：频繁分配和释放不同大小的堆内存，会导致内存空间被分割成多个不连续的小块（碎片），降低内存利用率。
四、存储内容
栈内存：主要存储短期存在的临时数据，如：
函数的局部变量、参数、返回值
函数调用的上下文（返回地址、寄存器状态等）。
堆内存：主要存储长期存在或动态大小的数据，如：
动态分配的数组、对象（如 C++ 的new Object()）
跨函数传递的大型数据（避免栈内存不足）。
五、安全性与管理成本
栈内存：
安全性高：自动释放，不会因忘记释放导致内存泄漏。
管理成本低：无需程序员干预，由编译器自动处理。
缺点：大小有限，若分配过大数据（如超大数组），会导致栈溢出（Stack Overflow）。
堆内存：
灵活性高：大小几乎不受限（仅受系统内存限制）。
管理成本高：需手动释放，若操作不当（如重复释放、忘记释放），会导致内存泄漏、野指针等问题。
线程安全：多线程操作堆内存时，需额外加锁保护，否则可能出现数据竞争。
总结
对比维度	栈内存（Stack）	堆内存（Heap）
分配 / 释放	自动（编译器）	手动（程序员）或 GC 自动
大小	小（几 MB）	大（GB 级别）
生命周期	与作用域绑定（函数内）	由程序员控制（或 GC 决定）
效率	高（连续内存，LIFO 操作）	低（需查找空闲块，可能有碎片）
典型用途	局部变量、函数参数、函数调用栈	动态数组、对象、跨作用域数据
安全性	高（无内存泄漏风险）	低（需手动管理，易出问题）




多线程死锁的必要条件
1. 互斥条件（Mutual Exclusion）
定义：线程对所分配的资源具有排他性的使用权限，即一个资源在同一时间只能被一个线程占用，其他线程若想使用该资源必须等待其释放。
示例：线程 A 占用了锁 1，线程 B 若想获取锁 1，必须等待线程 A 释放。
2. 持有并等待条件（Hold and Wait）
定义：一个线程已经持有了至少一个资源，同时又在等待获取其他线程已持有的资源。
示例：线程 A 持有锁 1，同时等待获取线程 B 持有的锁 2；而线程 B 持有锁 2，同时等待获取线程 A 持有的锁 1。
3. 不可剥夺条件（No Preemption）
定义：线程已获得的资源在未主动释放之前，不能被其他线程强行剥夺，只能由持有资源的线程主动释放。
示例：线程 A 持有锁 1 且未释放时，线程 B 无法强制夺取锁 1，只能等待线程 A 主动释放。
4. 循环等待条件（Circular Wait）
定义：存在一个线程集合，其中每个线程都在等待下一个线程所持有的资源，形成一个环形的等待链。
示例：线程 A 等待线程 B 的资源，线程 B 等待线程 C 的资源，线程 C 等待线程 A 的资源，三者形成循环等待。


POD：
在 C++ 中，POD（Plain Old Data） 是一种特殊的类型，指那些与 C 语言兼容的数据结构，可用于跨语言交互（如与 C 代码互操作）。POD 类型需满足特定规则，确保其内存布局简单且可预测。
POD 的特性
内存布局与 C 兼容：可直接与 C 语言的数据结构互操作（如通过 memcpy 复制）。
无复杂初始化：可使用 C 风格的初始化语法（如 {} 初始化列表）。
零初始化安全：可通过 memset 将内存置零，确保所有成员为零值。
判断是否为 POD
C++11 及以后版本提供 std::is_pod 类型特征来检查：


decltype
decltype(expression)  // 返回表达式的类型
在 C++ 中，decltype 是一个编译时类型推导工具，用于获取表达式的类型，而无需实际执行该表达式。它在模板编程、泛型编程和元编程中尤为重要。
int x = 42;
decltype(x) y = 10;  // y 的类型为 int
如：template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {  // C++11 尾随返回类型
    return t + u;
}


元编程
在 C++ 中，元编程（Metaprogramming） 是一种编写程序的技术，其核心是让程序在编译期自动生成或处理代码，而非在运行时执行。这种技术将计算逻辑从运行时转移到编译期，可显著提升性能并减少运行时开销。
常量表达式（constexpr）
C++11 引入的 constexpr 允许函数和变量在编译期求值。
// file1.h
extern int globalVar;  // 声明全局变量，不初始化

// file2.cpp
int globalVar = 42;  // 定义并初始化全局变量
extern void func();  // 显式声明
void func();
// 隐式声明（更常见）
extern 和 static 的区别
extern：声明全局变量或函数，链接到其他文件的定义。
static：限制变量或函数的作用域为当前文件（内部链接）。
Q2：何时需要显式使用 extern？
当需要在多个文件中共享全局变量时。
当需要引用其他文件的函数时（虽可省略，但显式使用更清晰）。
// C++ 文件
#include <iostream>
extern "C" {
    #include "c_header.h"  // C 语言头文件
}

int main() {
    c_function(42);  // 调用 C 函数
}
元编程优点：
元编程（Metaprogramming）是一种让程序在编译期自动生成或处理代码的技术，其核心优势在于将计算逻辑从运行时转移到编译期，从而带来显著的性能优化、代码简化和安全性提升。
核心优势
1. 性能优化
编译期计算：将耗时的计算（如数学公式、字符串处理）提前到编译期执行，减少运行时开销。
示例：编译期计算斐波那契数列（见前文模板元编程示例）。
代码特化：根据不同的类型或条件生成最优代码，避免运行时分支判断。

2. 代码精简与复用
自动生成重复代码：通过模板或宏减少样板代码，提高开发效率。

3. 类型安全增强
编译期类型检查：在编译时捕获类型错误，避免运行时崩溃。
示例：使用 static_assert 和概念（Concepts）约束模板参数



extern
在 C++ 中，extern 是一个存储类说明符，主要用于声明变量或函数的链接属性，告知编译器这些实体的定义存在于其他文件中
assert断言



#pragma once
在 C++ 中，#pragma once 是一种预处理指令，用于确保头文件在编译过程中只被包含一次，从而防止因重复包含导致的编译错误（如重复定义）。它是现代替代传统头文件保护（Header Guards）的更简洁方式
与传统头文件保护的对比
1. 传统方式（Header Guards）
使用宏定义防止重复包含：

cpp
运行
// a.h
#ifndef A_H
#define A_H

// 头文件内容
#endif // A_H



2. #pragma once 方式
cpp
运行
// a.h
#pragma once

// 头文件内容


c++常用网络请求库
主流跨平台库
1. libcurl
特点：功能全面，支持 HTTP/HTTPS/FTP 等多种协议，同步和异步模式，高度可定制。
适用场景：跨平台客户端开发，文件上传 / 下载，REST API 调用。

2. Boost.Beast
特点：基于 Boost.Asio，提供 HTTP/HTTPS 支持，异步 I/O，现代 C++ 接口。
适用场景：高性能服务器和客户端，需要异步处理大量连接

3. Poco C++ Libraries
特点：功能丰富的跨平台库，包含网络、XML、JSON 等模块，API 简洁。
适用场景：企业级应用、服务器开发，需要完整的网络栈支持。

轻量级库
1. cpp-httplib
特点：单头文件库，无依赖，仅支持 HTTP/HTTPS，易于集成。
适用场景：快速开发小型客户端，嵌入式系统。
2. RestClient-cpp
特点：轻量级 REST API 客户端，支持 JSON 解析（需结合 JSON 库）。

高级异步库
1. Qt Network
特点：基于 Qt 框架，提供事件驱动的网络编程，适合 GUI 应用。

2. Asio/Beast
特点：C++ 标准库 std::asio 的前身，提供底层异步 I/O 支持，适合高性能服务器。


Boost是C++的一个开源库集合，为标准库提供扩展功能，包含智能指针、容器、算法、多线程等组件，支持跨平台开发
线程池
在 C++ 开发中，Boost 库 是一个极其重要的工具集，它为 C++ 提供了许多核心语言尚未包含的高级特性和功能扩展。安装 Boost 的主要目的是为了利用其丰富的组件来简化开发、提升性能，并避免重复造轮子。以下是 Boost 的核心价值和典型应用场景：
一、Boost 的核心价值
1. 填补语言标准的空白
Boost 实现了许多后来被纳入 C++ 标准的功能（如智能指针、正则表达式、线程库等），是 C++ 标准库的 “试验田”。


Boost 是 C++ 开发者的 “瑞士军刀”，尤其在网络编程、系统开发、高性能计算等领域不可或缺。对于 Asio 项目，安装 Boost 可以：

简化网络编程，避免手动处理底层 socket API。
利用异步 I/O 提升并发性能。
借助 SSL 支持安全访问 HTTPS 接口。


线程池
1.future
在 C++ 中，std::future 是一个模板类，用于表示一个异步操作的未来结果。它是 C++11 标准库中并发编程的核心组件之一，与 std::promise、std::packaged_task 以及 std::async 共同构成了异步编程的基础设施。
std::future 的核心作用
异步结果的占位符
当你启动一个异步任务（如线程池中的任务），std::future 代表该任务最终会产生的结果。
通过 future，你可以在需要结果时获取它，而不必立即等待任务完成。
线程间通信
允许一个线程（生产者）设置结果，另一个线程（消费者）获取结果，实现线程间的数据同步。
状态管理
future 跟踪异步操作的状态（未完成、已完成、已取消），提供查询接口。

 获取结果
cpp
运行
T future::get();  // 阻塞当前线程，直到结果可用并返回它


注意：get() 只能被调用一次，多次调用会导致未定义行为。
2. 检查状态
cpp
运行
bool future::valid();  // 检查 future 是否有效（是否关联了异步结果）

3. 等待结果
cpp
运行
void future::wait();  // 阻塞直到结果可用
std::mutex（互斥锁）作用：保护共享资源，防止多个线程同时访问导致数据竞争
lock()：锁定互斥锁，若已被锁定则阻塞当前线程。
unlock()：解锁互斥锁。
try_lock()：尝试锁定，立即返回（成功返回 true，失败返回 false）。
std::lock_guard<std::mutex> lock(mtx);  // 自动加锁和解锁


std::condition_variable（条件变量）
作用：线程间的等待 - 通知机制，用于线程同步。
关键接口：
wait(lock)：释放锁并阻塞线程，直到被其他线程唤醒。
notify_one()：唤醒一个等待的线程。
notify_all()：唤醒所有等待的线程。

std::promise
std::chrono::duration

const std::chrono::time_point

std::unique_lock


为什么需要 [this]？
访问私有成员：lambda 内部默认无法直接访问类的私有成员，通过 this 可以突破访问限制。
延长对象生命周期：捕获 this 后，lambda 会持有对象的引用，避免对象在 lambda 执行前被销毁。
状态传递：将当前对象的状态带入 lambda，实现闭包。
workers.emplace_back([this] {//构建对象
    while (true) {
        std::function<void()> task;
        { // 临界区开始
            // 加锁等待任务
            std::unique_lock<std::mutex> lock(this->queue_mutex);
            this->condition.wait(lock, [this] {
                return this->stop || !this->tasks.empty();
                });

            // 如果线程池停止且没有任务，退出线程
            if (this->stop && this->tasks.empty())
                return;

            // 取出任务
            task = std::move(this->tasks.front());
            this->tasks.pop();
        }// 临界区结束，锁自动释放

        // 执行任务
        task();
    }
    });










